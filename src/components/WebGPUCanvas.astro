---
export interface Props {
  id?: string;
  width?: number;
  height?: number;
  vertexShader: string;
  fragmentShader: string;
  title?: string;
}

const {
  id = "webgpu-canvas",
  width = 800,
  height = 600,
  vertexShader,
  fragmentShader,
  title = Astro.locals.t('webgpu.demo.title'),
} = Astro.props;

// 准备i18n文本传递给客户端脚本
const i18nTexts = {
  error: Astro.locals.t('webgpu.demo.error'),
  errors: {
    notSupported: Astro.locals.t('webgpu.demo.errors.notSupported'),
    noAdapter: Astro.locals.t('webgpu.demo.errors.noAdapter'),
    canvasNotFound: Astro.locals.t('webgpu.demo.errors.canvasNotFound'),
    noContext: Astro.locals.t('webgpu.demo.errors.noContext'),
    initFailed: Astro.locals.t('webgpu.demo.errors.initFailed'),
  },
  labels: {
    vertexShader: Astro.locals.t('webgpu.demo.labels.vertexShader'),
    fragmentShader: Astro.locals.t('webgpu.demo.labels.fragmentShader'),
    renderPipeline: Astro.locals.t('webgpu.demo.labels.renderPipeline'),
    renderPass: Astro.locals.t('webgpu.demo.labels.renderPass'),
    commandEncoder: Astro.locals.t('webgpu.demo.labels.commandEncoder'),
  },
};
---

<div class="webgpu-demo">
  <h3>{title}</h3>
  <canvas id={id} width={width} height={height}></canvas>
  <div id={`${id}-error`} class="error-message" style="display: none;"></div>
</div>

<script define:vars={{ id, vertexShader, fragmentShader, i18nTexts }}>
  async function initWebGPU() {
    try {
      // 检查 WebGPU 支持
      if (!navigator.gpu) {
        throw new Error(i18nTexts.errors.notSupported);
      }

      // 获取 GPU 适配器
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) {
        throw new Error(i18nTexts.errors.noAdapter);
      }

      // 获取 GPU 设备
      const device = await adapter.requestDevice();

      // 获取 canvas 和上下文
      const canvas = document.getElementById(id);
      if (!canvas) {
        throw new Error(`${i18nTexts.errors.canvasNotFound}: ${id}`);
      }

      const context = canvas.getContext("webgpu");
      if (!context) {
        throw new Error(i18nTexts.errors.noContext);
      }

      // 配置 canvas 上下文
      const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
      context.configure({
        device: device,
        format: canvasFormat,
      });

      // 创建着色器模块
      const vertexShaderModule = device.createShaderModule({
        label: i18nTexts.labels.vertexShader,
        code: vertexShader,
      });

      const fragmentShaderModule = device.createShaderModule({
        label: i18nTexts.labels.fragmentShader,
        code: fragmentShader,
      });

      // 创建渲染管道
      const renderPipeline = device.createRenderPipeline({
        label: i18nTexts.labels.renderPipeline,
        layout: "auto",
        vertex: {
          module: vertexShaderModule,
          entryPoint: "vs_main",
        },
        fragment: {
          module: fragmentShaderModule,
          entryPoint: "fs_main",
          targets: [
            {
              format: canvasFormat,
            },
          ],
        },
        primitive: {
          topology: "triangle-list",
        },
      });

      // 渲染函数
      function render() {
        // 获取当前纹理视图
        const textureView = context.getCurrentTexture().createView();

        // 创建渲染通道编码器
        const renderPassDescriptor = {
          label: i18nTexts.labels.renderPass,
          colorAttachments: [
            {
              view: textureView,
              clearValue: { r: 0.3, g: 0.3, b: 0.3, a: 1.0 },
              loadOp: "clear",
              storeOp: "store",
            },
          ],
        };

        // 创建命令编码器
        const encoder = device.createCommandEncoder({
          label: i18nTexts.labels.commandEncoder,
        });

        // 开始渲染通道
        const pass = encoder.beginRenderPass(renderPassDescriptor);
        pass.setPipeline(renderPipeline);
        pass.draw(3); // 绘制 3 个顶点
        pass.end();

        // 提交命令
        const commandBuffer = encoder.finish();
        device.queue.submit([commandBuffer]);
      }

      // 执行渲染
      render();
    } catch (error) {
      console.error(`${i18nTexts.errors.initFailed}:`, error);
      const errorElement = document.getElementById(`${id}-error`);
      if (errorElement) {
        errorElement.style.display = "block";
        errorElement.innerHTML = `<strong>${i18nTexts.error}:</strong> ${error.message}`;
      }
    }
  }

  // 页面加载完成后初始化
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initWebGPU);
  } else {
    initWebGPU();
  }
</script>

<style>
  .webgpu-demo {
    margin: 2rem 0;
    padding: 1rem;
    border: 1px solid var(--sl-color-border);
    border-radius: 8px;
    background: var(--sl-color-bg-nav);
  }

  .webgpu-demo h3 {
    margin: 0 0 1rem 0;
    color: var(--sl-color-text);
    font-size: 1.2rem;
  }

  canvas {
    display: block;
    border: 1px solid var(--sl-color-border);
    border-radius: 4px;
    background: #2a2a2a;
    max-width: 100%;
    height: auto;
  }

  .error-message {
    margin-top: 1rem;
    padding: 1rem;
    background: var(--sl-color-bg-inline-code);
    border: 1px solid var(--sl-color-hairline-light);
    border-radius: 4px;
    color: var(--sl-color-white);
    font-size: 0.9rem;
    border-left: 4px solid #dc2626;
  }

  .error-message strong {
    color: #fca5a5;
  }
</style>
